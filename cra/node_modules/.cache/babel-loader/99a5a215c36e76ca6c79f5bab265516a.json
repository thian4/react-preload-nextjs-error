{"ast":null,"code":"import React from 'react';\nimport PropTypes from 'prop-types';\nimport ImageHelper from './ImageHelper';\nconst propTypes = {\n  // Rendered on success\n  children: PropTypes.element.isRequired,\n  // Rendered during load\n  loadingIndicator: PropTypes.node,\n  // Array of image urls to be preloaded\n  images: PropTypes.arrayOf(PropTypes.string),\n  // If set, the preloader will automatically show\n  // the children content after this amount of time\n  autoResolveDelay: PropTypes.number,\n  // Error callback. Is passed the error\n  onError: PropTypes.func,\n  // Success callback\n  onSuccess: PropTypes.func,\n  // Whether or not we should still show the content\n  // even if there is a preloading error\n  resolveOnError: PropTypes.bool,\n  // Whether or not we should mount the child content after\n  // images have finished loading (or after autoResolveDelay)\n  mountChildren: PropTypes.bool\n};\nconst defaultProps = {\n  loadingIndicator: null,\n  images: [],\n  autoResolveDelay: 0,\n  onError: null,\n  onSuccess: null,\n  resolveOnError: true,\n  mountChildren: true\n};\n\nclass Preload extends React.Component {\n  constructor(...args) {\n    var _temp;\n\n    return _temp = super(...args), this._mounted = false, this.state = {\n      ready: false\n    }, this.loadImages = () => {\n      const _this$props = this.props,\n            images = _this$props.images,\n            autoResolveDelay = _this$props.autoResolveDelay;\n      ImageHelper.loadImages(images).then(this._handleSuccess, this._handleError);\n\n      if (autoResolveDelay && autoResolveDelay > 0) {\n        this.autoResolveTimeout = setTimeout(this._handleAutoResolve, autoResolveDelay);\n      }\n    }, this._handleAutoResolve = () => {\n      this._handleSuccess({\n        didAutoResolve: true\n      });\n    }, this._handleSuccess = ({\n      didError,\n      didAutoResolve\n    } = {}) => {\n      if (this.autoResolveTimeout) {\n        clearTimeout(this.autoResolveTimeout);\n        this.autoResolveTimeout = null;\n      }\n\n      const ready = this.state.ready;\n\n      if (ready || !this._mounted) {\n        return;\n      }\n\n      this.setState({\n        ready: true\n      });\n      const onSuccess = this.props.onSuccess;\n\n      if (onSuccess) {\n        onSuccess({\n          didError,\n          didAutoResolve\n        });\n      }\n    }, this._handleError = err => {\n      if (!this._mounted) {\n        return;\n      }\n\n      const _this$props2 = this.props,\n            resolveOnError = _this$props2.resolveOnError,\n            onError = _this$props2.onError;\n\n      if (resolveOnError) {\n        this._handleSuccess({\n          didError: true,\n          error: err\n        });\n      }\n\n      if (onError) {\n        onError(err);\n      }\n    }, _temp;\n  }\n\n  componentWillMount() {\n    const images = this.props.images;\n\n    if (!images || images.length === 0) {\n      this._handleSuccess();\n    }\n  }\n\n  componentDidMount() {\n    this._mounted = true;\n    this.loadImages();\n  }\n\n  componentDidUpdate(prevProps) {\n    const images = this.props.images;\n    const oldImages = new Set(prevProps.images);\n    let hasChanged = false;\n\n    for (let i = 0; i < images.length; i += 1) {\n      const image = images[i];\n\n      if (!oldImages.has(image)) {\n        hasChanged = true;\n        break;\n      }\n    }\n\n    if (hasChanged) {\n      this.loadImages();\n    }\n  }\n\n  componentWillUnmount() {\n    this._mounted = false;\n\n    if (this.autoResolveTimeout) {\n      clearTimeout(this.autoResolveTimeout);\n    }\n  }\n\n  render() {\n    const ready = this.state.ready;\n    const _this$props3 = this.props,\n          mountChildren = _this$props3.mountChildren,\n          children = _this$props3.children,\n          loadingIndicator = _this$props3.loadingIndicator;\n    return ready && mountChildren ? children : loadingIndicator;\n  }\n\n}\n\nPreload.propTypes = propTypes;\nPreload.defaultProps = defaultProps;\nexport default Preload;","map":null,"metadata":{},"sourceType":"module"}